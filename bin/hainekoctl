#!/usr/bin/env perl
use feature ':5.10';
use strict;
use warnings;
use lib './lib';
use File::Basename qw/basename dirname/;
use Path::Class;
use Module::Load;

my $subcommand = shift @ARGV;
my $scriptname = basename $0;
my $methodargv = {};
my $hainekocmd = undef;
my $commandset = undef;
my $daemonargs = [ 'start', 'stop', 'reload', 'restart', 'status' ];

if( $subcommand ) {

    $commandset = join( ' ', $scriptname, @ARGV );
    if( grep { $subcommand eq $_ } @$daemonargs ) {
        #      _                                  
        #   __| | __ _  ___ _ __ ___   ___  _ __  
        #  / _` |/ _` |/ _ \ '_ ` _ \ / _ \| '_ \ 
        # | (_| | (_| |  __/ | | | | | (_) | | | |
        #  \__,_|\__,_|\___|_| |_| |_|\___/|_| |_|
        #                                         
        require Haineko::CLI::Daemon;
        my $scriptroot = Path::Class::Dir->new( dirname $0 );
        my $serverroot = $scriptroot->parent->absolute();
        $methodargv = {
            'command' => $commandset,
            'pidfile' => '/tmp/haineko.pid',
        };
        $hainekocmd = Haineko::CLI::Daemon->new( %$methodargv );

        if( $subcommand eq 'start' ) {
            # Start haineko server, run as a wrapper of ``plackup'' command.
            $hainekocmd->makepf;
            $hainekocmd->parseoptions;
            $hainekocmd->run;

        } else {
            # Sub command except ``start''
            $hainekocmd->parseoptions;

            if( $subcommand =~ m/(?:stop|reload|restart)/ ) {
                # ``stop'' or ``restart''
                $hainekocmd->ctrl( $subcommand );

            } else {
                # ``status'' sub command displays process id
                my $p = $hainekocmd->readpf;
                printf( STDERR "pid = %d\n", $p ) if defined $p;
            }
        }
    } else {
        # Sub commands except daemon mode
        if( $subcommand eq 'help' ) {
            # ``help'' sub command
            require Haineko::CLI;
            require Haineko::CLI::Help;
            my $climodules = [ 'Daemon', 'Setup', 'Password' ];

            $hainekocmd = Haineko::CLI::Help->new;
            for my $e ( @$climodules, '' ) {
                my $c = 'Haineko::CLI';
                $c .= '::'.$e if length $e;
                Module::Load::load( $c );
                $hainekocmd->add( $c->help('subcommand'), 'subcommand' );
            }
            $hainekocmd->mesg;
            help();
            exit(0);


        } elsif( $subcommand eq '--help' ) {
            # --help
            help();

        } elsif( $subcommand eq 'setup' ) {
            # Initialize: Distribute files for Haineko to current directory 
            # or specified directory.
            require Haineko::CLI::Setup;
            $methodargv = { 'command' => $commandset };
            $hainekocmd = Haineko::CLI::Setup->new( %$methodargv );
            $hainekocmd->parseoptions;
            $hainekocmd->init;

        } elsif( $subcommand eq 'pw' ) {
            # Generate a new password for BASIC-Authentication
            require Haineko::CLI::Password;
            $methodargv = { 'command' => $commandset };
            $hainekocmd = Haineko::CLI::Password->new( %$methodargv );
            $hainekocmd->parseoptions;
            print $hainekocmd->make;
            print "\n";
            exit(0);

        } elsif( $subcommand eq 'make-setup-data' ) {
            # Call Haineko::CLI::Setup->make
            require Haineko::CLI::Setup;
            $methodargv = { 'command' => $commandset };
            $hainekocmd = Haineko::CLI::Setup->new( %$methodargv );
            $hainekocmd->parseoptions;
            $hainekocmd->make;
            exit(0);

        } elsif( $subcommand eq 'version' ) {
            require Haineko::CLI;
            Haineko::CLI->version;
            exit(0);
        }
    }
} else {
    printf( STDERR "Try %s help\n", basename $scriptname );
}

sub help {
    printf( STDERR "Try '%s SUBCOMMAND --help'\n", $scriptname );
}
__END__
